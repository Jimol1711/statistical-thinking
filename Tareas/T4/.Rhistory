library(tidyr)
library(purrr)
# Para realizar plots
library(scatterplot3d)
library(ggplot2)
library(plotly)
# Manipulación de varios plots en una imagen.
library(gridExtra)
# Análisis bayesiano
library(rethinking)
dataMordidas <- read.csv("no_mordidas.csv", header = TRUE)
cols <- c("bites_month_1", "bites_month_2", "bites_month_3",
"bites_month_4", "bites_month_5", "bites_month_6",
"bites_month_7", "bites_month_8")
# Prior parameters
grid_len <- 100
p_grid <- seq(0, 1, length.out = grid_len)  # Grid of probabilities
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05) # Prior
posteriors <- c()
counted.months <- c()
p_grids <- rep(p_grid, 4)
for (n in c(1, 2, 4, 8)) {
bites <- rowSums(as.matrix(dataMordidas[, 1:n]))
likelihood <- dbinom(bites, size = n, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
posteriors <- c(posteriors, rep(posterior,grid_len))
counted.months <- c(counted.months, rep(n, grid_len))
}
post.df <- data.frame("grid" = rep(p_grid, 4), "posterior" = posteriors, "months" = counted.months)
# Graficar los resultados
ggplot(post.df) +
geom_line(aes(x = grid, y = posteriors)) +
facet_grid(months ~ .) +
labs(x = "Probabilidad de Mordida", y = "Posterior", title = "Distribución Posterior por Número de Meses")
cols <- c("bites_month_1", "bites_month_2", "bites_month_3",
"bites_month_4", "bites_month_5", "bites_month_6",
"bites_month_7", "bites_month_8")
# Prior uniforme
grid_len <- 100
p_grid <- seq(0, 1, length.out = grid_len)  # Grid de probabilidades
prior <- rep(1, grid_len)  # Prior uniforme
posteriors <- c()
counted.months <- c()
p_grids <- rep(p_grid, 4)
for (n in c(1, 2, 4, 8)) {
bites <- rowSums(as.matrix(dataMordidas[, 1:n]))
likelihood <- dbinom(bites, size = n, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
posteriors <- c(posteriors, rep(posterior, grid_len))
counted.months <- c(counted.months, rep(n, grid_len))
}
post.df <- data.frame("grid" = rep(p_grid, 4), "posterior" = posteriors, "months" = counted.months)
# Graficar los resultados
ggplot(post.df) +
geom_line(aes(x = grid, y = posteriors)) +
facet_grid(months ~ .) +
labs(x = "Probabilidad de Mordida", y = "Posterior", title = "Distribución Posterior por Número de Meses")
for (n in c(1, 2, 4, 8)) {
W <- sum(dataMordidas[, 1:n])
L <- n * 250 - W
# Adjust model
res <- quap(
alist(
W ~ dbinom(L, p),  # Likelihood
p ~ dunif(0, 1)    # Prior
),
data = list(W = W, L = L)
)
df <- precis(res)
# Graph the posterior curves
curve(dnorm(x, df$mean, df$sd), lty=2, add=FALSE,
xlab = "Probabilidad de mordida", ylab = "Densidad",
main = paste("Distribución posterior - Meses:", n))
}
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
# Function to calculate credible interval for given prob
cred_interval <- function(samples, prob) {
quantiles <- quantile(samples, probs = c((1 - prob) / 2, 1 - (1 - prob) / 2))
return(quantiles)
}
# Calculate intervals
cred_50 <- cred_interval(samples, 0.50)
cred_75 <- cred_interval(samples, 0.75)
cred_95 <- cred_interval(samples, 0.95)
cat("Intervalo de Credibilidad 50%: [", cred_50[1], ", ", cred_50[2], "]\n")
cat("Intervalo de Credibilidad 75%: [", cred_75[1], ", ", cred_75[2], "]\n")
cat("Intervalo de Credibilidad 95%: [", cred_95[1], ", ", cred_95[2], "]\n")
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.45, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
# Function to calculate credible interval for given prob
cred_interval <- function(samples, prob) {
quantiles <- quantile(samples, probs = c((1 - prob) / 2, 1 - (1 - prob) / 2))
return(quantiles)
}
# Calculate intervals
cred_50 <- cred_interval(samples, 0.50)
cred_75 <- cred_interval(samples, 0.75)
cred_95 <- cred_interval(samples, 0.95)
cat("Intervalo de Credibilidad 50%: [", cred_50[1], ", ", cred_50[2], "]\n")
cat("Intervalo de Credibilidad 75%: [", cred_75[1], ", ", cred_75[2], "]\n")
cat("Intervalo de Credibilidad 95%: [", cred_95[1], ", ", cred_95[2], "]\n")
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.45, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.4, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
# Function to calculate credible interval for given prob
cred_interval <- function(samples, prob) {
quantiles <- quantile(samples, probs = c((1 - prob) / 2, 1 - (1 - prob) / 2))
return(quantiles)
}
# Calculate intervals
cred_50 <- cred_interval(samples, 0.50)
cred_75 <- cred_interval(samples, 0.75)
cred_95 <- cred_interval(samples, 0.95)
cat("Intervalo de Credibilidad 50%: [", cred_50[1], ", ", cred_50[2], "]\n")
cat("Intervalo de Credibilidad 75%: [", cred_75[1], ", ", cred_75[2], "]\n")
cat("Intervalo de Credibilidad 95%: [", cred_95[1], ", ", cred_95[2], "]\n")
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
# Function to calculate credible interval for given prob
cred_interval <- function(samples, prob) {
quantiles <- quantile(samples, probs = c((1 - prob) / 2, 1 - (1 - prob) / 2))
return(quantiles)
}
# Calculate intervals
cred_50 <- cred_interval(samples, 0.50)
cred_75 <- cred_interval(samples, 0.75)
cred_95 <- cred_interval(samples, 0.95)
cat("Intervalo de Credibilidad 50%: [", cred_50[1], ", ", cred_50[2], "]\n")
cat("Intervalo de Credibilidad 75%: [", cred_75[1], ", ", cred_75[2], "]\n")
cat("Intervalo de Credibilidad 95%: [", cred_95[1], ", ", cred_95[2], "]\n")
# Usamos las muestras posterior obtenidas en el paso anterior
# Asumimos que 'samples' es el vector de las muestras de la posterior.
# Función para calcular el HDPI
HDPI <- function(samples, prob = 0.95) {
# Ordenamos las muestras
sorted_samples <- sort(samples)
# Calculamos el número de elementos que deben estar en el intervalo
n <- length(sorted_samples)
idx <- floor(n * (1 - prob) / 2)
# Encontramos el intervalo de mayor densidad
hdp_interval <- sorted_samples[c(idx + 1, n - idx)]
return(hdp_interval)
}
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HDPI(samples, prob = 0.50)
hdpi_75 <- HDPI(samples, prob = 0.75)
hdpi_95 <- HDPI(samples, prob = 0.95)
# Mostrar los intervalos HDPI
cat("Intervalo HDPI 50%: [", hdpi_50[1], ", ", hdpi_50[2], "]\n")
cat("Intervalo HDPI 75%: [", hdpi_75[1], ", ", hdpi_75[2], "]\n")
cat("Intervalo HDPI 95%: [", hdpi_95[1], ", ", hdpi_95[2], "]\n")
# Graficar los resultados
library(ggplot2)
ggplot(data.frame(samples), aes(x = samples)) +
geom_density(fill = "lightblue") +
geom_vline(aes(xintercept = hdpi_50[1]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_50[2]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[1]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[2]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[1]), color = "blue", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[2]), color = "blue", linetype = "dashed") +
labs(title = "Densidad Posterior con Intervalos HDPI",
x = "Parámetro", y = "Densidad") +
theme_minimal()
# Usamos las muestras posterior obtenidas en el paso anterior
# Asumimos que 'samples' es el vector de las muestras de la posterior.
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HDPI(samples, prob = 0.50)
hdpi_75 <- HDPI(samples, prob = 0.75)
hdpi_95 <- HDPI(samples, prob = 0.95)
# Mostrar los intervalos HDPI
cat("Intervalo HDPI 50%: [", hdpi_50[1], ", ", hdpi_50[2], "]\n")
cat("Intervalo HDPI 75%: [", hdpi_75[1], ", ", hdpi_75[2], "]\n")
cat("Intervalo HDPI 95%: [", hdpi_95[1], ", ", hdpi_95[2], "]\n")
# Graficar los resultados
library(ggplot2)
ggplot(data.frame(samples), aes(x = samples)) +
geom_density(fill = "lightblue") +
geom_vline(aes(xintercept = hdpi_50[1]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_50[2]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[1]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[2]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[1]), color = "blue", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[2]), color = "blue", linetype = "dashed") +
labs(title = "Densidad Posterior con Intervalos HDPI",
x = "Parámetro", y = "Densidad") +
theme_minimal()
View(HDPI)
View(HDPI)
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
library(purrr)
# Para realizar plots
library(scatterplot3d)
library(ggplot2)
library(plotly)
# Manipulación de varios plots en una imagen.
library(gridExtra)
# Análisis bayesiano
library(rethinking)
dataMordidas <- read.csv("no_mordidas.csv", header = TRUE)
cols <- c("bites_month_1", "bites_month_2", "bites_month_3",
"bites_month_4", "bites_month_5", "bites_month_6",
"bites_month_7", "bites_month_8")
# Prior parameters
grid_len <- 100
p_grid <- seq(0, 1, length.out = grid_len)  # Grid of probabilities
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05) # Prior
posteriors <- c()
counted.months <- c()
p_grids <- rep(p_grid, 4)
for (n in c(1, 2, 4, 8)) {
bites <- rowSums(as.matrix(dataMordidas[, 1:n]))
likelihood <- dbinom(bites, size = n, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
posteriors <- c(posteriors, rep(posterior,grid_len))
counted.months <- c(counted.months, rep(n, grid_len))
}
post.df <- data.frame("grid" = rep(p_grid, 4), "posterior" = posteriors, "months" = counted.months)
# Graficar los resultados
ggplot(post.df) +
geom_line(aes(x = grid, y = posteriors)) +
facet_grid(months ~ .) +
labs(x = "Probabilidad de Mordida", y = "Posterior", title = "Distribución Posterior por Número de Meses")
cols <- c("bites_month_1", "bites_month_2", "bites_month_3",
"bites_month_4", "bites_month_5", "bites_month_6",
"bites_month_7", "bites_month_8")
# Prior uniforme
grid_len <- 100
p_grid <- seq(0, 1, length.out = grid_len)  # Grid de probabilidades
prior <- rep(1, grid_len)  # Prior uniforme
posteriors <- c()
counted.months <- c()
p_grids <- rep(p_grid, 4)
for (n in c(1, 2, 4, 8)) {
bites <- rowSums(as.matrix(dataMordidas[, 1:n]))
likelihood <- dbinom(bites, size = n, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
posteriors <- c(posteriors, rep(posterior, grid_len))
counted.months <- c(counted.months, rep(n, grid_len))
}
post.df <- data.frame("grid" = rep(p_grid, 4), "posterior" = posteriors, "months" = counted.months)
# Graficar los resultados
ggplot(post.df) +
geom_line(aes(x = grid, y = posteriors)) +
facet_grid(months ~ .) +
labs(x = "Probabilidad de Mordida", y = "Posterior", title = "Distribución Posterior por Número de Meses")
for (n in c(1, 2, 4, 8)) {
W <- sum(dataMordidas[, 1:n])
L <- n * 250 - W
# Adjust model
res <- quap(
alist(
W ~ dbinom(L, p),  # Likelihood
p ~ dunif(0, 1)    # Prior
),
data = list(W = W, L = L)
)
df <- precis(res)
# Graph the posterior curves
curve(dnorm(x, df$mean, df$sd), lty=2, add=FALSE,
xlab = "Probabilidad de mordida", ylab = "Densidad",
main = paste("Distribución posterior - Meses:", n))
}
grid_len <- 1000
p_grid <- seq(0, 1, length.out = grid_len)
prior <- dnorm(p_grid, mean = 0.6, sd = 0.05)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
likelihood <- dbinom(bites, size = 8, prob = p_grid)
unstd.posterior <- prior * likelihood
posterior <- unstd.posterior / sum(unstd.posterior)
samples <- sample(p_grid, prob = posterior, size = 1e4, replace = TRUE)
dens(samples)
# Intervalos:
proporcion_0_035 <- mean(samples >= 0 & samples <= 0.35)
proporcion_035_045 <- mean(samples > 0.35 & samples <= 0.45)
proporcion_mayor_045 <- mean(samples > 0.45)
# Print proportions
cat("Proporción en el rango [0, 0.35]:", proporcion_0_035, "\n")
cat("Proporción en el rango (0.35, 0.45]:", proporcion_035_045, "\n")
cat("Proporción en el rango (>0.45):", proporcion_mayor_045, "\n")
# Function to calculate credible interval for given prob
cred_interval <- function(samples, prob) {
quantiles <- quantile(samples, probs = c((1 - prob) / 2, 1 - (1 - prob) / 2))
return(quantiles)
}
# Calculate intervals
cred_50 <- cred_interval(samples, 0.50)
cred_75 <- cred_interval(samples, 0.75)
cred_95 <- cred_interval(samples, 0.95)
cat("Intervalo de Credibilidad 50%: [", cred_50[1], ", ", cred_50[2], "]\n")
cat("Intervalo de Credibilidad 75%: [", cred_75[1], ", ", cred_75[2], "]\n")
cat("Intervalo de Credibilidad 95%: [", cred_95[1], ", ", cred_95[2], "]\n")
# Usamos las muestras posterior obtenidas en el paso anterior
# Asumimos que 'samples' es el vector de las muestras de la posterior.
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HDPI(samples, prob = 0.50)
install.packages("rethinking")
# Manipulación de estructuras
library(tidyverse)
library(dplyr)
library(tidyr)
library(purrr)
# Para realizar plots
library(scatterplot3d)
library(ggplot2)
library(plotly)
# Manipulación de varios plots en una imagen.
library(gridExtra)
# Análisis bayesiano
library(rethinking)
install.packages("rethinking")
# Usamos las muestras posterior obtenidas en el paso anterior
# Asumimos que 'samples' es el vector de las muestras de la posterior.
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HDPI(samples, prob = 0.50)
library(rethinking)
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HDPI(samples, prob = 0.50)
# Calculamos los intervalos HDPI para 50%, 75% y 95%
hdpi_50 <- HPDI(samples, prob = 0.50)
hdpi_75 <- HPDI(samples, prob = 0.75)
hdpi_95 <- HPDI(samples, prob = 0.95)
# Mostrar los intervalos HDPI
cat("Intervalo HDPI 50%: [", hdpi_50[1], ", ", hdpi_50[2], "]\n")
cat("Intervalo HDPI 75%: [", hdpi_75[1], ", ", hdpi_75[2], "]\n")
cat("Intervalo HDPI 95%: [", hdpi_95[1], ", ", hdpi_95[2], "]\n")
# Graficar los resultados
library(ggplot2)
ggplot(data.frame(samples), aes(x = samples)) +
geom_density(fill = "lightblue") +
geom_vline(aes(xintercept = hdpi_50[1]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_50[2]), color = "red", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[1]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_75[2]), color = "green", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[1]), color = "blue", linetype = "dashed") +
geom_vline(aes(xintercept = hdpi_95[2]), color = "blue", linetype = "dashed") +
labs(title = "Densidad Posterior con Intervalos HDPI",
x = "Parámetro", y = "Densidad") +
theme_minimal()
# Calculate intervals with HPDI function from rethinking
hdpi_50 <- HPDI(samples, prob = 0.50)
hdpi_75 <- HPDI(samples, prob = 0.75)
hdpi_95 <- HPDI(samples, prob = 0.95)
cat("Intervalo HDPI 50%: [", hdpi_50[1], ", ", hdpi_50[2], "]\n")
cat("Intervalo HDPI 75%: [", hdpi_75[1], ", ", hdpi_75[2], "]\n")
cat("Intervalo HDPI 95%: [", hdpi_95[1], ", ", hdpi_95[2], "]\n")
library(ggplot2)
# 1. Calcular el ratio real de carteros mordidos
# 'bites' es el número total de mordidas observadas
# 'n' es el número de carteros (observaciones)
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
n <- nrow(dataMordidas)  # Número de carteros (observaciones)
ratio.real <- sum(bites) / (n * 8)  # Ratio real de carteros mordidos
# 2. Simular 10,000 réplicas de mordidas a partir del posterior
# Usamos las muestras obtenidas en la parte anterior (posterior)
# Suponiendo que ya tienes 'samples' que es el posterior
# Vamos a simular las predicciones de mordidas para cada réplica
simulated_bites <- sapply(samples, function(p) {
rbinom(n, size = 8, prob = p)  # Generar una réplica de mordidas para cada muestra de posterior
})
# Calcular el ratio de carteros mordidos para cada réplica
simulated_ratios <- rowSums(simulated_bites) / (n * 8)
# 3. Graficar la distribución de los ratios simulados con el ratio real
ggplot() +
geom_density(aes(x = simulated_ratios)) +  # Densidad de los ratios simulados
geom_vline(aes(xintercept = ratio.real), color = "red") +  # Línea roja para el ratio real
labs(x = "Ratio de Carteros Mordidos", y = "Densidad", title = "Distribución de Ratios Simulados vs. Ratio Real")
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
n <- nrow(dataMordidas)
ratio.real <- sum(bites) / (n * 8)
simulated_bites <- sapply(samples, function(p) {
rbinom(n, size = 8, prob = p)
})
simulated_ratios <- rowSums(simulated_bites) / (n * 8)
ggplot() +
geom_density(aes(x = simulated_ratios)) +
geom_vline(aes(xintercept = ratio.real), color = "red") +
labs(x = "Ratio de Carteros Mordidos", y = "Densidad", title = "Distribución de Ratios Simulados vs. Ratio Real")
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
n <- nrow(dataMordidas)
ratio.real <- sum(bites) / (n * 8)
simulated_bites <- sapply(samples, function(p) {
rbinom(n, size = 8, prob = p)
})
simulated_ratios <- rowSums(simulated_bites) / (n * 8)
ggplot() +
geom_density(aes(x = simulated_ratios)) +
geom_vline(aes(xintercept = ratio.real), color = "red") +
labs(x = "Ratio de Carteros Mordidos", y = "Densidad", title = "Distribución de Ratios Simulados vs. Ratio Real")
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
n <- nrow(dataMordidas)
ratio.real <- sum(bites) / (n * 8)
simulated_bites <- sapply(samples, function(p) {
rbinom(n, size = 8, prob = p)
})
simulated_ratios <- rowSums(simulated_bites) / (n * 8)
ggplot() +
geom_density(aes(samples)) +
geom_vline(aes(xintercept = ratio.real), color = "red") +
labs(x = "Ratio de Carteros Mordidos", y = "Densidad", title = "Distribución de Ratios Simulados vs. Ratio Real")
bites <- rowSums(as.matrix(dataMordidas[, 1:8]))
n <- nrow(dataMordidas)
ratio.real <- sum(bites) / (n * 8)
simulated_bites <- sapply(samples, function(p) {
rbinom(n, size = 8, prob = p)
})
simulated_ratios <- rowSums(simulated_bites) / (n * 8)
ggplot() +
geom_density(aes(simulated_ratios)) +
geom_vline(aes(xintercept = ratio.real), color = "red") +
labs(x = "Ratio de Carteros Mordidos", y = "Densidad", title = "Distribución de Ratios Simulados vs. Ratio Real")
